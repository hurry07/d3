<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <link type="text/css" rel="stylesheet" href="css/theme.css"/>
    <script type="text/javascript" src="../d3.js"></script>
    <script type="text/javascript" src="api/mootools-core-1.4.5.js"></script>
    <script type="text/javascript" src="api/utils.js"></script>
    <script type="text/javascript" src="api/node.js"></script>
    <script type="text/javascript" src="api/operation.js"></script>
    <script type="text/javascript" src="api/gl-matrix.js"></script>
</head>
<body>
<div class='chart'>
</div>
<div id='input' class="floating">
    <input type="text" class="fieldinput">
</div>
<script type="text/javascript">
// ======================
// camera
// ======================
function Camera(svg) {
    this.svg = svg;
    this.width = svg.attr('width');
    this.height = svg.attr('height');
    this.x = 0;
    this.y = 0;
    this.scalef = 1;

    // touch start
    this.startx = 0;
    this.starty = 0;

    this.rect = svg.append('svg:rect')
            .attr('fill', 'url(#gridPattern)')
            .on('mouseout', this.handleOut)
            .on('mouseover', this.handleOver);
    this.apply();
}
Camera.prototype.getScale = function () {
    return this.scalef;
}
Camera.prototype.setStart = function (x, y) {
    this.x = x;
    this.y = y;
}
/**
 * 对屏幕上指定的点缩放
 *
 * @param scalef
 * @param currentx
 * @param currenty
 */
Camera.prototype.scale = function (scalef, currentx, currenty) {
    this.scalef = scalef;
    this.apply();
}
Camera.prototype.apply = function (endx, endy) {
    var portx = this.x;
    var porty = this.y;
    var w = this.width = window.innerWidth;
    var h = this.height = window.innerHeight;
    var sw = w / this.scalef;
    var sh = h / this.scalef;
    this.svg.attr('viewBox', portx + ' ' + porty + ' ' + sw + ' ' + sh)
            .attr('width', w)
            .attr('height', h);

    this.rect.attr('x', portx)
            .attr('y', porty)
            .attr('width', sw)
            .attr('height', sh);
}
// ======================
// global
// ======================
var svg = d3.selectAll('.chart')
        .append("svg")
        .attr('width', window.innerWidth)
        .attr('height', window.innerHeight)
        .attr('id', 'svg');

svg.append('svg:defs')
        .append('svg:pattern')
        .attr('id', 'gridPattern')
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', 15)
        .attr('height', 15)
        .attr('patternUnits', 'userSpaceOnUse')
        .append('svg:path')
        .attr('d', 'M 15 0 L 0 0 0 15')
        .attr('fill', 'none')
        .attr('stroke', '#6DA0A1')
        .attr('stroke-width', '0.25');

var group = svg.append('svg:g')
        .attr('transform', 'translate(100, 400) scale(1,-1)')

var camera = new Camera(svg);

// global listeners register
window.addEventListener('resize', function () {
    var width = window.innerWidth;
    var height = window.innerHeight;
//    camera.setStart(-100, 50);
//    camera.scale(1.2, 0, 0);
    camera.apply();
});

function todegree(r) {
    return r / Math.PI * 180;
}
function Lines(linewidth) {
    this.path = '';
    this.linewidth = linewidth;
    this.color = 'lightblue';
}
Lines.prototype.frustumStart = function (b) {
    this.fstart = b;
}
Lines.prototype.frustumEnd = function (b) {
    this.fend = b;
}
Lines.prototype.setColor = function (c) {
    this.color = c;
}
/**
 * @param points [xy...]
 */
Lines.prototype.genPath = function (points) {
    var half = Math.PI / 2;
    var degrees = [];
    for (var i = 0, l = points.length - 2 , gx, gy; i < l; i += 2) {
        gx = points[i + 2] - points[i], gy = points[i + 3] - points[i + 1];
        var dis = Math.sqrt(gx * gx + gy * gy);
        if (gy < 0) {
            degrees.push(-Math.acos(gx / dis));
        } else {
            degrees.push(Math.acos(gx / dis));
        }
    }

    var outline = [];
    var rightdegree = degrees[0], w, pindex = 0;

    // append start
    if (this.fstart) {
        this.appendArray(outline, points[0], points[1], -this.linewidth * Math.sin(rightdegree), this.linewidth * Math.cos(rightdegree));
    } else {
        this.appendArray(outline, points[0], points[1], 0, this.linewidth / Math.cos(rightdegree));// append start
    }

    for (var i = 0, l = degrees.length - 1, d1, d2; i < l; i++) {
        d1 = degrees[i], d2 = degrees[i + 1];
        if (d1 > d2) {
            d2 += Math.PI * 2;
        }
        rightdegree = half + (d1 + d2) / 2;
        w = this.linewidth / Math.sin(rightdegree - d2);
        pindex += 2;
        this.appendArray(outline, points[pindex], points[pindex + 1], w * Math.cos(rightdegree), w * Math.sin(rightdegree));
    }

    // append stop
    pindex += 2;
    rightdegree = degrees[l];
    if (this.fend) {
        this.appendArray(outline, points[pindex], points[pindex + 1], -this.linewidth * Math.sin(rightdegree), this.linewidth * Math.cos(rightdegree));
    } else {
        this.appendArray(outline, points[pindex], points[pindex + 1], 0, this.linewidth / Math.cos(degrees[l]));
    }

    return outline;
}
Lines.prototype.initSize = function (w, h, rows, cols, rectw, recth) {
    this.width = w;
    this.height = h;
    this.rowcount = rows;
    this.colcount = cols;
    this.rectw = rectw;
    this.recth = recth;

    this.cells = [];
    this.cellsflag = [];
    this.cellcount = 0;

    this.drawBackground();
}
Lines.prototype.reset = function () {
    this.cellcount = 0;
    this.cells = [];
    this.cellsflag = [];
}
Lines.prototype.setStart = function (offsetx, y) {
    this.start = {offset: offsetx, y: y};
}
Lines.prototype.setEnd = function (offsetx, y) {
    this.end = {offset: offsetx, y: y};
}
Lines.prototype.addPoint = function (index, isrect) {
    this.cells[this.cellcount] = index;
    this.cellsflag[this.cellcount] = isrect ? true : false;
    this.cellcount++;
}
Lines.prototype.setup = function () {
    // ---------------------- split lines
    var turns = [0];
    var rectcount = this.isRect(0);
    for (var i = 1, count = this.cellcount - 1; i < count; i++) {
        if (this.isRect(i)) {
            turns.push(i);
            rectcount++;
        } else if (this.getLean(i - 1) != this.getLean(i)) {
            turns.push(i);
        }
    }
    turns.push(count);

    console.log(turns.join(','));
    console.log('----------------------');

    var points = [];

    // append start
    this.appendStart(points, 0);

    // append inner links
    if (rectcount > 0 || turns.length > 2) {
        var jumpstart = false;
        var jumpend = false;
        for (var i = 0, previous = -1, next = 1, count = turns.length; i < count; i++, previous++, next++) {
            var cell = turns[i];

            // first points
            if (previous == -1) {
                var lean = this.getLean(cell);
                if (this.isRect(cell)) {
                    this.appendRectY(points, cell, true);
                    this.flushPoints(points);

                    this.appendRectPoint(points, cell, lean, false);
                } else {
                    if (lean == 1) {
                        jumpstart = true;
                    } else {
                        this.appendCellY(points, cell, lean, true);
                    }
                }
            } else if (next == count) {
                // last point
                var lean = this.getLean(turns[i - 1]);
                if (this.isRect(cell)) {
                    this.appendRectPoint(points, cell, lean, true);
                    this.flushPoints(points);

                    this.appendRectY(points, cell, false);
                } else {
                    if (jumpend) {
                        var precell = turns[previous];
                        if (this.isRect(precell)) {
                            this.appendRectY(points, precell, false);
                        } else {
                            this.appendCellY(points, precell, this.getLean(turns[i - 2]), false);
                        }
                    } else {
                        this.appendCellY(points, cell, lean, false);
                    }
                }
            } else {
                // delay the next line begin
                if (next == count - 1 && this.getLean(cell) == 1 && !this.isRect(turns[i + 1])) {
                    jumpend = true;
                }

                if (this.isRect(cell)) {
                    if (jumpstart) {
                        this.appendRectY(points, 1, true);
                    } else {
                        this.appendRectPoint(points, cell, this.getLean(turns[i - 1]), true);
                    }
                    this.flushPoints(points);

                    if (!jumpend) {
                        this.appendRectPoint(points, cell, this.getLean(cell), false);
                    }
                } else {
                    if (jumpstart) {
                        this.appendCellY(points, cell, this.getLean(turns[i]), true);
                    } else {
                        if (!jumpend) {
                            this.appendCellCenter(points, cell);
                        }
                    }
                }
                jumpstart = false;
            }
        }
    }

    // append end
    this.appendEnd(points, this.cellcount - 1);
    this.flushPoints(points);

    // append rect
    for (var i = 0, count = this.cellcount; i < count; i++) {
        if (this.isRect(i)) {
            var rectpoints = [];
            this.appendRect(rectpoints, i);
            this.appendPoints(rectpoints);
        }
    }
}
Lines.prototype.appendRectPoint = function (ps, index, lean, start) {
    index = this.cells[index];

    var halfw = this.rectw / 2;
    var halfh = this.recth / 2;
    var col = index % this.colcount;
    var row = (index - col) / this.colcount;
    var cx = ( col + 0.5) / this.colcount * this.width;
    var cy = (row + 0.5) / this.rowcount * this.height;
    var sign = start ? -1 : 1;

    if (lean == 1) {
        ps.push(cx + halfw * sign);
        ps.push(cy);
    } else if (lean > 0) {
        ps.push(cx + halfw * sign);
        ps.push(cy + halfh * sign);
    } else {
        ps.push(cx + halfw * sign);
        ps.push(cy - halfh * sign);
    }
}
Lines.prototype.appendRect = function (ps, index) {
    index = this.cells[index];

    var halfw = this.rectw / 2;
    var halfh = this.recth / 2;
    var col = index % this.colcount;
    var row = (index - col) / this.colcount;
    var cx = ( col + 0.5) / this.colcount * this.width;
    var cy = (row + 0.5) / this.rowcount * this.height;
    ps.push(cx);
    ps.push(cy - halfh);
    ps.push(cx + halfw);
    ps.push(cy - halfh);
    ps.push(cx + halfw);
    ps.push(cy + halfh);
    ps.push(cx - halfw);
    ps.push(cy + halfh);
    ps.push(cx - halfw);
    ps.push(cy - halfh);
    ps.push(cx);
    ps.push(cy - halfh);
}
Lines.prototype.isRect = function (index) {
    return this.cellsflag[index];
}
Lines.prototype.getLean = function (cindex) {
    return this.cells[cindex + 1] - this.cells[cindex];
}
Lines.prototype.drawBackground = function () {
    for (var i = 0; i < this.colcount; i++) {
        var x = this.width / this.colcount * i;
        group.append('svg:path')
                .attr('d', 'M' + x + ',0 L' + x + ',' + this.height)
                .style('fill', 'none')
                .style('stroke', '#FC9C9C');
    }
    for (var i = 0; i < this.rowcount; i++) {
        var h = this.height / this.rowcount * i;
        group.append('svg:path')
                .attr('d', 'M0,' + h + ' L' + this.width + ',' + h)
                .style('fill', 'none')
                .style('stroke', '#FC9C9C');
    }
    group.append('svg:rect')
            .attr('width', this.width)
            .attr('height', this.height)
            .style('fill', 'none')
            .style('stroke', '#FC9C9C');
}
Lines.prototype.getLeanTan = function (nextlean) {
    var dx, dy;
    if (nextlean > 0) {
        dx = nextlean % this.colcount;
    } else {
        dx = nextlean % this.colcount;
        if (dx < 0) {
            dx += this.colcount;
        }
    }
    dy = (nextlean - dx) / this.colcount;

    var disx = dx / this.colcount * this.width;
    var disy = dy / this.rowcount * this.height;
    return disx / disy;
}
Lines.prototype.appendCellCenter = function (ps, index) {
    index = this.cells[index];
    var col = index % this.colcount;
    var row = (index - col) / this.colcount;
    ps.push((col + 0.5) / this.colcount * this.width);
    ps.push((row + 0.5) / this.rowcount * this.height);
}
Lines.prototype.getRectLeft = function (index) {
    return (index % this.colcount + 0.5) / this.colcount * this.width - this.rectw / 2;
}
Lines.prototype.getRectRight = function (index) {
    return (index % this.colcount + 0.5) / this.colcount * this.width + this.rectw / 2;
}
Lines.prototype.appendRectY = function (ps, index, start) {
    index = this.cells[index];
    var col = index % this.colcount;
    var row = (index - col) / this.colcount;
    ps.push((col + 0.5) / this.colcount * this.width + (start ? -this.rectw / 2 : this.rectw / 2));
    ps.push(row / this.rowcount * this.height + (start ? this.start.y : this.end.y));
}
Lines.prototype.appendCellY = function (ps, index, lean, start) {
    index = this.cells[index];
    var oy = start ? this.start.y : this.end.y;
    var gy = this.height / this.rowcount / 2 - oy;
    var col = index % this.colcount;
    var row = (index - col) / this.colcount;
    var cx = (col + 0.5) / this.colcount * this.width;
    var cy = row / this.rowcount * this.height;
    var tan = this.getLeanTan(lean);
    ps.push(cx - gy * this.getLeanTan(lean), cy + oy);
}
Lines.prototype.appendStart = function (ps, index) {
    index = this.cells[index];
    var col = index % this.colcount;
    var row = (index - col) / this.colcount;
    ps.push(col / this.colcount * this.width - this.start.offset);
    ps.push(row / this.rowcount * this.height + this.start.y);
}
Lines.prototype.appendEnd = function (ps, index) {
    index = this.cells[index];
    var col = index % this.colcount;
    var row = (index - col) / this.colcount;
    col += 1;
    ps.push(col / this.colcount * this.width + this.end.offset);
    ps.push(row / this.rowcount * this.height + this.end.y);
}
Lines.prototype.appendArray = function (arr, x, y, ox, oy) {
    arr.push(x - ox);
    arr.push(y - oy);
    arr.push(x + ox);
    arr.push(y + oy);
}
Lines.prototype.flushPoints = function (points) {
    this.appendPoints(points);
    points.splice(0, points.length);
}
Lines.prototype.appendPoints = function (points) {
    var borders = this.genPath(points);
    var p = 'M' + borders.slice(0, 2).join(',');
    for (var i = 4, l = borders.length; i < l; i += 4) {
        p += ' L' + borders.slice(i, i + 2).join(',');
    }
    for (var i = borders.length - 2; i > 0; i -= 4) {
        p += ' L' + borders.slice(i, i + 2).join(',');
    }
    p += 'Z';
    console.log(p);

    group.append('svg:path')
            .attr('d', p)
            .style('fill', this.color);
}

//var line = new Lines(10);
//    line.appendPoints([0, 10, 100, 10, 100, 110, 200, 110]);
//    line.appendPoints([0, 200, 100, 400, 200, 200, 300, 400, 400, 200]);
//    line.appendPoints([0, 500, 100, 300, 200, 500, 300, 300, 400, 300]);
//    line.appendPoints([300, 40, 400, 100, 500, 120, 600, 400, 700, 300, 800, 300]);
//line.frustumStart(true);
//line.frustumEnd(true);
//line.appendPoints([100, 100, 200, 100, 200, 200, 100, 200, 100, 100]);
//line.appendPoints([300, 100, 300, 200, 400, 200, 400, 100, 300, 100]);
//line.appendPoints([150, 300, 100, 300, 100, 400, 200, 400, 200, 300, 180, 300]);
//line.appendPoints([350, 300, 400, 300, 400, 400, 300, 400, 300, 300, 320, 300]);

//var rline = new Lines(10);
//rline.setColor('#E9967A');
//rline.appendPoints([200, 200, 300, 300]);
//
//rline.setColor('#DA70D6');
//rline.frustumStart(true);
//rline.frustumEnd(true);
//rline.appendPoints([200, 300, 300, 200]);
//
//var x = 600, y = 250, r = 100;
//var points = [x + r, 100];
//for (var i = 0; i < 6; i++) {
//    var radius = i * 60 / 180 * Math.PI;
//    points.push(x + r * Math.cos(radius));
//    points.push(y + r * Math.sin(radius));
//}
//rline.appendPoints(points);
//
//x = 250, y = 600;
//var points = [100, y + r];
//for (var i = 0; i < 6; i++) {
//    var radius = (90 - i * 60 ) / 180 * Math.PI;
//    points.push(x + r * Math.cos(radius));
//    points.push(y + r * Math.sin(radius));
//}
//rline.appendPoints(points);
//
//rline.setStart(20, 10);
//rline.setEnd(20, 10);
//rline.initSize(500, 300, 3, 5);
//
//rline.addPoint(10);
//rline.addPoint(6);
//rline.addPoint(2);
//rline.addPoint(8);
//rline.addPoint(14);
//rline.setup();
//rline.reset();
//
//rline.addPoint(0);
//rline.addPoint(6);
//rline.addPoint(2);
//rline.addPoint(8);
//rline.addPoint(4);
//rline.setup();
//rline.reset();
//
//rline.addPoint(10);
//rline.addPoint(11);
//rline.addPoint(12);
//rline.addPoint(8);
//rline.addPoint(4);
//rline.setup();
//rline.reset();
//
//rline.addPoint(5);
//rline.addPoint(6);
//rline.addPoint(7);
//rline.addPoint(8);
//rline.addPoint(4);
//rline.setup();
//rline.reset();


var rline = new Lines(5);
rline.setStart(20, 15);
rline.setEnd(20, 20);
rline.frustumStart(true);
rline.frustumEnd(true);
rline.initSize(500, 300, 3, 5, 80, 80);

//rline.addPoint(0);
//rline.addPoint(11);
//rline.addPoint(12);
//rline.addPoint(3);
//rline.addPoint(4);
//rline.setup();
//rline.reset();

rline.addPoint(10);
rline.addPoint(11, true);
rline.addPoint(2);
rline.addPoint(3);
rline.addPoint(4, true);
rline.setup();
rline.reset();

//    svg.on('mouseover.start', function () {
//        console.log('----------------------');
//        console.log('container.start');
//        console.log(this, arguments);
//        console.log(d3.event);
//        console.log(d3.event.eventPhase);
//    }, true)
//            .on('mouseover.end', function () {
//                console.log('container.end');
//                console.log(this, arguments);
//                console.log(d3.event);
//                console.log(d3.event.eventPhase);
//                console.log('----------------------');
//            })
//    svg.append('svg:rect')
//            .attr('width', 100)
//            .attr('height', 100)
//            .on('mouseover', function () {
//                console.log(this, arguments);
//                console.log(d3.event);
//                console.log(d3.event.eventPhase);
//            })
//
//    var evt = document.createEvent("MouseEvents");
//    evt.initMouseEvent("mouseover",
//            true,// canBubble
//            true,// cancelable
//            window,
//            0,// detail
//            50, 50, 50, 50, //
//            false, false, false, false, 0, null);
//    console.log(evt.hasOwnProperty('eventPhase'));
//    evt.eventPhase = 1;
//    evt.test = 1111;
//    this.svg.node().dispatchEvent(evt);
</script>
</body>
</html>