<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <link type="text/css" rel="stylesheet" href="css/theme.css"/>
    <script type="text/javascript" src="../d3.js"></script>
    <script type="text/javascript" src="api/mootools-core-1.4.5.js"></script>
    <script type="text/javascript" src="api/utils.js"></script>
    <script type="text/javascript" src="api/node.js"></script>
    <script type="text/javascript" src="api/operation.js"></script>
    <script type="text/javascript" src="api/gl-matrix.js"></script>
</head>
<body>
<div class='chart'>
</div>
<div id='input' class="floating">
    <input type="text" class="fieldinput">
</div>
<script type="text/javascript">
// ======================
// camera
// ======================
function Camera(svg) {
    this.svg = svg;
    this.width = svg.attr('width');
    this.height = svg.attr('height');
    this.x = 0;
    this.y = 0;
    this.scalef = 1;

    // touch start
    this.startx = 0;
    this.starty = 0;

    this.rect = svg.append('svg:rect')
            .attr('fill', 'url(#gridPattern)')
            .on('mouseout', this.handleOut)
            .on('mouseover', this.handleOver);
    this.apply();
}
Camera.prototype.getScale = function () {
    return this.scalef;
}
Camera.prototype.setStart = function (x, y) {
    this.x = x;
    this.y = y;
}
/**
 * 对屏幕上指定的点缩放
 *
 * @param scalef
 * @param currentx
 * @param currenty
 */
Camera.prototype.scale = function (scalef, currentx, currenty) {
    this.scalef = scalef;
    this.apply();
}
Camera.prototype.apply = function (endx, endy) {
    var portx = this.x;
    var porty = this.y;
    var w = this.width = window.innerWidth;
    var h = this.height = window.innerHeight;
    var sw = w / this.scalef;
    var sh = h / this.scalef;
    this.svg.attr('viewBox', portx + ' ' + porty + ' ' + sw + ' ' + sh)
            .attr('width', w)
            .attr('height', h);

    this.rect.attr('x', portx)
            .attr('y', porty)
            .attr('width', sw)
            .attr('height', sh);
}
// ======================
// global
// ======================
var svg = d3.selectAll('.chart')
        .append("svg")
        .attr('width', window.innerWidth)
        .attr('height', window.innerHeight)
        .attr('id', 'svg');

svg.append('svg:defs')
        .append('svg:pattern')
        .attr('id', 'gridPattern')
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', 15)
        .attr('height', 15)
        .attr('patternUnits', 'userSpaceOnUse')
        .append('svg:path')
        .attr('d', 'M 15 0 L 0 0 0 15')
        .attr('fill', 'none')
        .attr('stroke', '#6DA0A1')
        .attr('stroke-width', '0.25');

var group = svg.append('svg:g')
        .attr('transform', 'translate(100, 100)');

var camera = new Camera(svg);

// global listeners register
window.addEventListener('resize', function () {
    var width = window.innerWidth;
    var height = window.innerHeight;
//    camera.setStart(-100, 50);
//    camera.scale(1.2, 0, 0);
    camera.apply();
});

function todegree(r) {
    return r / Math.PI * 180;
}
function Lines(linewidth) {
    this.path = '';
    this.linewidth = linewidth;
    this.color = 'lightblue';
}
Lines.prototype.frustumStart = function (b) {
    this.fstart = b;
}
Lines.prototype.frustumEnd = function (b) {
    this.fend = b;
}
Lines.prototype.setColor = function (c) {
    this.color = c;
}
/**
 * @param points [xy...]
 */
Lines.prototype.genPath = function (points) {
    var half = Math.PI / 2;
    var degrees = [];
    for (var i = 0, l = points.length - 2 , gx, gy; i < l; i += 2) {
        gx = points[i + 2] - points[i], gy = points[i + 3] - points[i + 1];
        var dis = Math.sqrt(gx * gx + gy * gy);
        if (gy < 0) {
            degrees.push(-Math.acos(gx / dis));
        } else {
            degrees.push(Math.acos(gx / dis));
        }
    }

    var outline = [];
    var rightdegree = degrees[0], w, pindex = 0;

    // append start
    if (this.fstart) {
        this.appendArray(outline, points[0], points[1], -this.linewidth * Math.sin(rightdegree), this.linewidth * Math.cos(rightdegree));
    } else {
        this.appendArray(outline, points[0], points[1], 0, this.linewidth / Math.cos(rightdegree));// append start
    }

    for (var i = 0, l = degrees.length - 1, d1, d2; i < l; i++) {
        d1 = degrees[i], d2 = degrees[i + 1];
        if (d1 > d2) {
            d2 += Math.PI * 2;
        }
        rightdegree = half + (d1 + d2) / 2;
        w = this.linewidth / Math.sin(rightdegree - d2);
        pindex += 2;
        this.appendArray(outline, points[pindex], points[pindex + 1], w * Math.cos(rightdegree), w * Math.sin(rightdegree));
    }

    // append stop
    pindex += 2;
    rightdegree = degrees[l];
    if (this.fend) {
        this.appendArray(outline, points[pindex], points[pindex + 1], -this.linewidth * Math.sin(rightdegree), this.linewidth * Math.cos(rightdegree));
    } else {
        this.appendArray(outline, points[pindex], points[pindex + 1], 0, this.linewidth / Math.cos(degrees[l]));
    }

    return outline;
}
Lines.prototype.initSize = function (w, h, rows, cols, rectw, recth) {
    this.width = w;
    this.height = h;
    this.rowcount = rows;
    this.colcount = cols;
    this.rectw = rectw;
    this.recth = recth;

    this.cells = [];
    this.cellsflag = [];
    this.cellcount = 0;

    this.drawBackground();
}
Lines.prototype.reset = function () {
    this.cellcount = 0;
}
Lines.prototype.setStart = function (offsetx, y) {
    this.start = {offset: offsetx, y: y};
}
Lines.prototype.setEnd = function (offsetx, y) {
    this.end = {offset: offsetx, y: y};
}
Lines.prototype.addPoint = function (index, isrect) {
    this.cells[this.cellcount] = index;
    this.cellsflag[this.cellcount] = isrect ? true : false;
    this.cellcount++;
}
Lines.prototype.setup = function () {
    // ---------------------- split lines
    var lines = [0];
    if (this.isRect(0)) {
        lines.push(0);
    }
    var count = this.cellcount - 1;
    for (var i = 1; i < count; i++) {
        if (this.isRect(i)) {
            lines.push(i);
            lines.push(i);
        } else if (this.getLean(i - 1) != this.getLean(i)) {
            lines.push(i);
        }
    }
    lines.push(count);
    if (this.isRect(count)) {
        lines.push(count);
    }

    console.log(lines.join(','));
    console.log('----------------------');

    // ---------------------- setup line
    var points = [];
    this.appendCellStart(points, this.getCell(0), -this.start.offset, this.start.y);

    // ---------------------- link to first point
    var lindex = 0;
    var last = 0;// 0: point; 1: rect
    var lean = 0;
    for (; lindex < 2; lindex++) {
        var cell = lines[lindex];
        lean = this.getLean(cell);

        if (this.isRect(cell)) {
            last = 1;
            this.appendHeaderRect(points, this.getCell(cell), this.start.y);
            this.flushPoints(points);
            break;
        } else {
            if (lean != 1) {
                this.appendCellEndLean(points, cell, this.start.y, lean);
                break;
            }
        }
    }

    // ---------------------- link inner
    var length = lines.length - 2;
    for (; lindex < length; lindex++) {
        if (lines[lindex] == lines[lindex + 1]) {
            continue;
        }
        if (last == 1) {
            this.appendRectPoint(points, lines[lindex], lean, false);
        }
        if (this.isRect(lines[lindex])) {
            this.appendRectPoint(points, lines[lindex], lean, true);
            this.flushPoints(points);
            last = 1;
        } else {
            this.appendCellCenter(points, lines[lindex]);
            last = 0;
        }
        lean = this.getLean(lines[lindex]);
    }

    // ---------------------- link tail
    if (length > 0) {
        if (lines[length] == lines[length + 1]) {
            this.appendRectPoint(points, lines[lindex], lean, false);
            this.flushPoints(points);

            this.appendTailRect(points, this.getCell(lines[length]), this.end.y);
        } else {
            if (this.getLean(lines[length]) == 1) {
                if (this.isRect(lines[length])) {
                    this.appendTailRect(points, this.getCell(lines[length]), this.end.y);
                }
            } else {
                if (this.isRect(lines[length])) {

                } else {

                }
            }
        }
    }

    // ---------------------- finish
    this.appendCellEnd(points, this.getCell(count), this.start.offset, this.start.y);
    this.appendPoints(points);

    // ---------------------- append rect
    lindex = 0, length = lines.length;
    for (; lindex < length; lindex++) {
        if (this.isRect(lines[0])) {
            var rectpoints = [];
            this.appendRect(rectpoints, this.getCell(lines[0]));
            this.appendPoints(rectpoints);
        }
    }
}
Lines.prototype.appendRectPoint = function (ps, index, lean, isBegin) {
    var halfw = this.rectw / 2;
    var halfh = this.recth / 2;
    var col = index % this.colcount;
    var row = (index - col) / this.colcount;
    var cx = ( col + 0.5) / this.colcount * this.width;
    var cy = (row + 0.5) / this.rowcount * this.height;
    var sign = isBegin ? 1 : -1;
    if (lean == 1) {
        ps.push(cx + halfw * sign);
        ps.push(cy);
    } else if (lean > 0) {
        ps.push(cx + halfw * sign);
        ps.push(cy + halfh * sign);
    } else {
        ps.push(cx + halfw * sign);
        ps.push(cy - halfh * sign);
    }
}
Lines.prototype.appendRect = function (ps, index) {
    var halfw = this.rectw / 2;
    var halfh = this.recth / 2;
    var col = index % this.colcount;
    var row = (index - col) / this.colcount;
    var cx = ( col + 0.5) / this.colcount * this.width;
    var cy = (row + 0.5) / this.rowcount * this.height;
    ps.push(cx);
    ps.push(cy - halfh);
    ps.push(cx + halfw);
    ps.push(cy - halfh);
    ps.push(cx + halfw);
    ps.push(cy + halfh);
    ps.push(cx - halfw);
    ps.push(cy + halfh);
    ps.push(cx - halfw);
    ps.push(cy - halfh);
    ps.push(cx);
    ps.push(cy - halfh);
}
Lines.prototype.appendHeaderRect = function (ps, index, y) {
    var col = index % this.colcount;
    var row = (index - col) / this.colcount;
    ps.push((col + 0.5) / this.colcount * this.width - this.rectw / 2);
    ps.push(row / this.rowcount * this.height + y);
}
Lines.prototype.appendTailRect = function (ps, index, y) {
    var col = index % this.colcount;
    var row = (index - col) / this.colcount;
    ps.push((col + 0.5) / this.colcount * this.width + this.rectw / 2);
    ps.push(row / this.rowcount * this.height + y);
}
Lines.prototype.isRect = function (cindex) {
    return this.cellsflag[cindex];
}
Lines.prototype.getCell = function (cindex) {
    return this.cells[cindex];
}
Lines.prototype.getRect = function (line) {
    for (var i = line[0], l = line[1] + 1; i < l; i++) {
        if (this.cellsflag[i]) {
            return i;
        }
    }
    return -1;
}
Lines.prototype.getLean = function (cindex) {
    return this.cells[cindex + 1] - this.cells[cindex];
}
Lines.prototype.drawBackground = function () {
    for (var i = 0; i < this.colcount; i++) {
        var x = this.width / this.colcount * i;
        group.append('svg:path')
                .attr('d', 'M' + x + ',0 L' + x + ',' + this.height)
                .style('fill', 'none')
                .style('stroke', '#FC9C9C');
    }
    for (var i = 0; i < this.rowcount; i++) {
        var h = this.height / this.rowcount * i;
        group.append('svg:path')
                .attr('d', 'M0,' + h + ' L' + this.width + ',' + h)
                .style('fill', 'none')
                .style('stroke', '#FC9C9C');
    }
    group.append('svg:rect')
            .attr('width', this.width)
            .attr('height', this.height)
            .style('fill', 'none')
            .style('stroke', '#FC9C9C');
}
Lines.prototype.getLeanTan = function (nextlean) {
    var dx, dy;
    if (nextlean > 0) {
        dx = nextlean % this.colcount;
    } else {
        dx = nextlean % this.colcount;
        if (dx < 0) {
            dx += this.colcount;
        }
    }
    dy = (nextlean - dx) / this.colcount;

    var disx = dx / this.colcount * this.width;
    var disy = dy / this.rowcount * this.height;
    return disx / disy;
}
Lines.prototype.appendCellCenter = function (ps, index) {
    var col = index % this.colcount;
    var row = (index - col) / this.colcount;
    ps.push((col + 0.5) / this.colcount * this.width);
    ps.push((row + 0.5) / this.rowcount * this.height);
}
Lines.prototype.appendCellEndLean = function (ps, index, oy, lean) {
    var gy = this.height / this.rowcount / 2 - oy;
    this.appendCellStart(ps, index, this.width / this.colcount / 2 - gy * this.getLeanTan(lean), oy);
}
Lines.prototype.appendCellStartLean = function (ps, index, oy, lean) {
    var gy = this.height / this.rowcount / 2 - oy;
    this.appendCellStart(ps, index, this.width / this.colcount / 2 + gy * this.getLeanTan(lean), oy);
}
Lines.prototype.appendCellStart = function (ps, index, ox, oy) {
    var col = index % this.colcount;
    var row = (index - col) / this.colcount;
    ps.push(col / this.colcount * this.width + ox);
    ps.push(row / this.rowcount * this.height + oy);
}
Lines.prototype.appendCellEnd = function (ps, index, ox, oy) {
    var col = index % this.colcount;
    var row = (index - col) / this.colcount;
    col += 1;
    ps.push(col / this.colcount * this.width + ox);
    ps.push(row / this.rowcount * this.height + oy);
}
Lines.prototype.appendArray = function (arr, x, y, ox, oy) {
    arr.push(x - ox);
    arr.push(y - oy);
    arr.push(x + ox);
    arr.push(y + oy);
}
Lines.prototype.flushPoints = function (points) {
    this.appendPoints(points);
    points.splice(0, points.length);
}
Lines.prototype.appendPoints = function (points) {
    var borders = this.genPath(points);
    var p = 'M' + borders.slice(0, 2).join(',');
    for (var i = 4, l = borders.length; i < l; i += 4) {
        p += ' L' + borders.slice(i, i + 2).join(',');
    }
    for (var i = borders.length - 2; i > 0; i -= 4) {
        p += ' L' + borders.slice(i, i + 2).join(',');
    }
    p += 'Z';
    console.log(p);

    group.append('svg:path')
            .attr('d', p)
            .style('fill', this.color);
}

//var line = new Lines(10);
//    line.appendPoints([0, 10, 100, 10, 100, 110, 200, 110]);
//    line.appendPoints([0, 200, 100, 400, 200, 200, 300, 400, 400, 200]);
//    line.appendPoints([0, 500, 100, 300, 200, 500, 300, 300, 400, 300]);
//    line.appendPoints([300, 40, 400, 100, 500, 120, 600, 400, 700, 300, 800, 300]);
//line.frustumStart(true);
//line.frustumEnd(true);
//line.appendPoints([100, 100, 200, 100, 200, 200, 100, 200, 100, 100]);
//line.appendPoints([300, 100, 300, 200, 400, 200, 400, 100, 300, 100]);
//line.appendPoints([150, 300, 100, 300, 100, 400, 200, 400, 200, 300, 180, 300]);
//line.appendPoints([350, 300, 400, 300, 400, 400, 300, 400, 300, 300, 320, 300]);

//var rline = new Lines(10);
//rline.setColor('#E9967A');
//rline.appendPoints([200, 200, 300, 300]);
//
//rline.setColor('#DA70D6');
//rline.frustumStart(true);
//rline.frustumEnd(true);
//rline.appendPoints([200, 300, 300, 200]);
//
//var x = 600, y = 250, r = 100;
//var points = [x + r, 100];
//for (var i = 0; i < 6; i++) {
//    var radius = i * 60 / 180 * Math.PI;
//    points.push(x + r * Math.cos(radius));
//    points.push(y + r * Math.sin(radius));
//}
//rline.appendPoints(points);
//
//x = 250, y = 600;
//var points = [100, y + r];
//for (var i = 0; i < 6; i++) {
//    var radius = (90 - i * 60 ) / 180 * Math.PI;
//    points.push(x + r * Math.cos(radius));
//    points.push(y + r * Math.sin(radius));
//}
//rline.appendPoints(points);
//
//rline.setStart(20, 10);
//rline.setEnd(20, 10);
//rline.initSize(500, 300, 3, 5);
//
//rline.addPoint(10);
//rline.addPoint(6);
//rline.addPoint(2);
//rline.addPoint(8);
//rline.addPoint(14);
//rline.setup();
//rline.reset();
//
//rline.addPoint(0);
//rline.addPoint(6);
//rline.addPoint(2);
//rline.addPoint(8);
//rline.addPoint(4);
//rline.setup();
//rline.reset();
//
//rline.addPoint(10);
//rline.addPoint(11);
//rline.addPoint(12);
//rline.addPoint(8);
//rline.addPoint(4);
//rline.setup();
//rline.reset();
//
//rline.addPoint(5);
//rline.addPoint(6);
//rline.addPoint(7);
//rline.addPoint(8);
//rline.addPoint(4);
//rline.setup();
//rline.reset();


var rline = new Lines(5);
rline.setStart(20, 15);
rline.setEnd(20, 15);
rline.initSize(500, 300, 3, 5, 80, 80);
rline.addPoint(5, true);
rline.addPoint(6);
rline.addPoint(7);
rline.addPoint(8, true);
rline.addPoint(9);
rline.setup();
rline.reset();

//    svg.on('mouseover.start', function () {
//        console.log('----------------------');
//        console.log('container.start');
//        console.log(this, arguments);
//        console.log(d3.event);
//        console.log(d3.event.eventPhase);
//    }, true)
//            .on('mouseover.end', function () {
//                console.log('container.end');
//                console.log(this, arguments);
//                console.log(d3.event);
//                console.log(d3.event.eventPhase);
//                console.log('----------------------');
//            })
//    svg.append('svg:rect')
//            .attr('width', 100)
//            .attr('height', 100)
//            .on('mouseover', function () {
//                console.log(this, arguments);
//                console.log(d3.event);
//                console.log(d3.event.eventPhase);
//            })
//
//    var evt = document.createEvent("MouseEvents");
//    evt.initMouseEvent("mouseover",
//            true,// canBubble
//            true,// cancelable
//            window,
//            0,// detail
//            50, 50, 50, 50, //
//            false, false, false, false, 0, null);
//    console.log(evt.hasOwnProperty('eventPhase'));
//    evt.eventPhase = 1;
//    evt.test = 1111;
//    this.svg.node().dispatchEvent(evt);
</script>
</body>
</html>